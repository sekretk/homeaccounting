---
type: frontend
description: React Frontend Patterns and Templates
globs:
  - "src/**/*.tsx"
  - "src/**/*.ts"
  - "src/**/*.css"
alwaysApply: true
---

# üñºÔ∏è Frontend Development Rules - React + TypeScript

## File Structure for New Entity
```
frontend/src/app/[entity-name]/
‚îú‚îÄ‚îÄ [EntityName].tsx               # Main page component
‚îú‚îÄ‚îÄ [EntityName].module.css        # Component-specific styles
‚îî‚îÄ‚îÄ components/
    ‚îú‚îÄ‚îÄ [EntityName]List.tsx       # List/grid component
    ‚îú‚îÄ‚îÄ [EntityName]Form.tsx       # Create/edit form
    ‚îú‚îÄ‚îÄ [EntityName]Detail.tsx     # Detail view
    ‚îî‚îÄ‚îÄ [EntityName]Card.tsx       # Individual item card
```

## 1. Main Page Component Template
```typescript
// [EntityName].tsx
import React, { useState, useEffect, useCallback } from 'react';
import { [EntityName] } from '@shared/entities';
import { [EntityName]List } from './components/[EntityName]List';
import { [EntityName]Form } from './components/[EntityName]Form';
import styles from './[EntityName].module.css';

interface [EntityName]PageProps {}

export const [EntityName]Page: React.FC<[EntityName]PageProps> = () => {
  const [entities, setEntities] = useState<[EntityName][]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showForm, setShowForm] = useState(false);
  const [editingEntity, setEditingEntity] = useState<[EntityName] | null>(null);

  const fetchEntities = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch('/api/[entity-name]');
      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.statusText}`);
      }
      
      const data: [EntityName][] = await response.json();
      setEntities(data);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Unknown error occurred';
      setError(message);
      console.error('Error fetching entities:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchEntities();
  }, [fetchEntities]);

  const handleCreate = () => {
    setEditingEntity(null);
    setShowForm(true);
  };

  const handleEdit = (entity: [EntityName]) => {
    setEditingEntity(entity);
    setShowForm(true);
  };

  const handleFormClose = () => {
    setShowForm(false);
    setEditingEntity(null);
  };

  const handleFormSuccess = async () => {
    setShowForm(false);
    setEditingEntity(null);
    await fetchEntities(); // Refresh the list
  };

  const handleDelete = async (id: string) => {
    if (!confirm('Are you sure you want to delete this item? This action cannot be undone.')) {
      return;
    }

    try {
      const response = await fetch(`/api/[entity-name]/${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        throw new Error(`Failed to delete: ${response.statusText}`);
      }

      await fetchEntities(); // Refresh the list
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to delete item';
      setError(message);
      console.error('Error deleting entity:', err);
    }
  };

  if (loading) {
    return (
      <div className={styles.container}>
        <div className={styles.loading}>
          <div className={styles.spinner}></div>
          <p>Loading [EntityName] data...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className={styles.container}>
        <div className={styles.error}>
          <h2>Error</h2>
          <p>{error}</p>
          <button onClick={fetchEntities} className={styles.retryButton}>
            Try Again
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className={styles.container}>
      <header className={styles.header}>
        <div className={styles.headerContent}>
          <h1>[EntityName] Management</h1>
          <p>Manage your [entity-name] items</p>
        </div>
        <button 
          onClick={handleCreate}
          className={styles.primaryButton}
        >
          Add [EntityName]
        </button>
      </header>

      <main className={styles.main}>
        <[EntityName]List
          entities={entities}
          onEdit={handleEdit}
          onDelete={handleDelete}
          loading={loading}
        />
      </main>

      {showForm && (
        <[EntityName]Form
          entity={editingEntity}
          onClose={handleFormClose}
          onSuccess={handleFormSuccess}
        />
      )}
    </div>
  );
};
```

## 2. List Component Template
```typescript
// components/[EntityName]List.tsx
import React from 'react';
import { [EntityName] } from '@shared/entities';
import { [EntityName]Card } from './[EntityName]Card';
import styles from './[EntityName]List.module.css';

interface [EntityName]ListProps {
  entities: [EntityName][];
  onEdit: (entity: [EntityName]) => void;
  onDelete: (id: string) => void;
  loading?: boolean;
}

export const [EntityName]List: React.FC<[EntityName]ListProps> = ({
  entities,
  onEdit,
  onDelete,
  loading = false,
}) => {
  if (loading) {
    return (
      <div className={styles.loading}>
        <div className={styles.skeletonGrid}>
          {Array.from({ length: 6 }).map((_, index) => (
            <div key={index} className={styles.skeletonCard} />
          ))}
        </div>
      </div>
    );
  }

  if (entities.length === 0) {
    return (
      <div className={styles.emptyState}>
        <div className={styles.emptyIcon}>üìã</div>
        <h3>No [EntityName] items yet</h3>
        <p>Get started by creating your first [entity-name] item.</p>
      </div>
    );
  }

  return (
    <div className={styles.container}>
      <div className={styles.grid}>
        {entities.map((entity) => (
          <[EntityName]Card
            key={entity.id}
            entity={entity}
            onEdit={onEdit}
            onDelete={onDelete}
          />
        ))}
      </div>
    </div>
  );
};
```

## 3. Form Component Template
```typescript
// components/[EntityName]Form.tsx
import React, { useState, useEffect } from 'react';
import { [EntityName] } from '@shared/entities';
import styles from './[EntityName]Form.module.css';

interface [EntityName]FormProps {
  entity?: [EntityName] | null;
  onClose: () => void;
  onSuccess: () => void;
}

interface FormData {
  name: string;
  description: string;
  isActive: boolean;
}

export const [EntityName]Form: React.FC<[EntityName]FormProps> = ({
  entity,
  onClose,
  onSuccess,
}) => {
  const [formData, setFormData] = useState<FormData>({
    name: '',
    description: '',
    isActive: true,
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (entity) {
      setFormData({
        name: entity.name || '',
        description: entity.description || '',
        isActive: entity.isActive ?? true,
      });
    }
  }, [entity]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError(null);

    try {
      const url = entity ? `/api/[entity-name]/${entity.id}` : '/api/[entity-name]';
      const method = entity ? 'PUT' : 'POST';

      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.message || `Failed to ${entity ? 'update' : 'create'} [entity-name]`);
      }

      onSuccess();
    } catch (err) {
      const message = err instanceof Error ? err.message : 'An error occurred';
      setError(message);
      console.error('Form submission error:', err);
    } finally {
      setLoading(false);
    }
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value, type } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? (e.target as HTMLInputElement).checked : value,
    }));
  };

  return (
    <div className={styles.overlay}>
      <div className={styles.modal}>
        <header className={styles.header}>
          <h2>{entity ? 'Edit' : 'Create'} [EntityName]</h2>
          <button 
            onClick={onClose}
            className={styles.closeButton}
            aria-label="Close"
          >
            ‚úï
          </button>
        </header>

        <form onSubmit={handleSubmit} className={styles.form}>
          {error && (
            <div className={styles.error}>
              {error}
            </div>
          )}

          <div className={styles.field}>
            <label htmlFor="name">Name *</label>
            <input
              id="name"
              name="name"
              type="text"
              value={formData.name}
              onChange={handleChange}
              required
              disabled={loading}
              className={styles.input}
            />
          </div>

          <div className={styles.field}>
            <label htmlFor="description">Description</label>
            <textarea
              id="description"
              name="description"
              value={formData.description}
              onChange={handleChange}
              disabled={loading}
              className={styles.textarea}
              rows={3}
            />
          </div>

          <div className={styles.field}>
            <label className={styles.checkboxLabel}>
              <input
                name="isActive"
                type="checkbox"
                checked={formData.isActive}
                onChange={handleChange}
                disabled={loading}
                className={styles.checkbox}
              />
              Active
            </label>
          </div>

          <footer className={styles.footer}>
            <button
              type="button"
              onClick={onClose}
              className={styles.cancelButton}
              disabled={loading}
            >
              Cancel
            </button>
            <button
              type="submit"
              className={styles.submitButton}
              disabled={loading}
            >
              {loading ? 'Saving...' : entity ? 'Update' : 'Create'}
            </button>
          </footer>
        </form>
      </div>
    </div>
  );
};
```

## 4. CSS Module Template
```css
/* [EntityName].module.css */
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 2rem;
  padding-bottom: 2rem;
  border-bottom: 1px solid #e0e0e0;
}

.headerContent h1 {
  margin: 0 0 0.5rem 0;
  color: #333;
  font-size: 2rem;
  font-weight: 600;
}

.headerContent p {
  margin: 0;
  color: #666;
  font-size: 1rem;
}

.primaryButton {
  background: #007bff;
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}

.primaryButton:hover {
  background: #0056b3;
}

.primaryButton:disabled {
  background: #6c757d;
  cursor: not-allowed;
}

.main {
  min-height: 400px;
}

.loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 4rem 2rem;
  color: #666;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #f3f3f3;
  border-top: 4px solid #007bff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 1rem;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.error {
  text-align: center;
  padding: 2rem;
  background: #f8d7da;
  color: #721c24;
  border-radius: 8px;
  margin: 2rem 0;
}

.error h2 {
  margin: 0 0 1rem 0;
}

.error p {
  margin: 0 0 1.5rem 0;
}

.retryButton {
  background: #dc3545;
  color: white;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 6px;
  cursor: pointer;
}

.retryButton:hover {
  background: #c82333;
}

/* Responsive Design */
@media (max-width: 768px) {
  .container {
    padding: 1rem;
  }

  .header {
    flex-direction: column;
    gap: 1rem;
    align-items: stretch;
  }

  .headerContent {
    text-align: center;
  }

  .primaryButton {
    width: 100%;
  }
}
```

## 5. Routing Integration

Add to your main App routing:
```typescript
// App.tsx or routes configuration
import { [EntityName]Page } from './[entity-name]/[EntityName]';

// In your routes
<Route path="/[entity-name]" element={<[EntityName]Page />} />
```

## üéØ Frontend Standards

### Component Structure
- Use functional components with hooks
- Keep components small and focused
- Use TypeScript interfaces for props
- Add proper error boundaries

### State Management
- Use useState for local state
- Use useCallback for event handlers
- Use useEffect for side effects
- Consider useContext for shared state

### Styling
- Use CSS modules for component-specific styles
- Follow BEM-like naming conventions
- Add responsive design considerations
- Use CSS custom properties for theming

### Error Handling
- Always handle async errors
- Show meaningful error messages
- Provide retry mechanisms
- Log errors to console for debugging

### Accessibility
- Add proper ARIA labels
- Use semantic HTML elements
- Ensure keyboard navigation works
- Add proper focus management

### Performance
- Use React.memo for expensive components
- Implement proper loading states
- Add skeleton screens for better UX
- Optimize re-renders with useCallback/useMemo

## üöÄ Best Practices

- Keep components pure and testable
- Use TypeScript interfaces for all props
- Implement proper error boundaries
- Add loading states for all async operations
- Use proper form validation
- Implement responsive design
- Add proper accessibility attributes
- Follow React naming conventions